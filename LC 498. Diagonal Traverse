class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
        int m=mat.size();
        int n=mat[0].size();
        int row=0,column=0;
        bool upd=1;
        vector<int> ans;
        while(row<m&&column<n){
            ans.push_back(mat[row][column]);
            int rowN,columnN;
            if(upd){
                rowN = row-1;
                columnN = column+1;
            }
            else{
                rowN = row+1;
                columnN = column-1;
            }
            if(rowN<0 || rowN>=m || columnN<0 || columnN>=n){
                if(upd){
                    if(column==n-1){
                        row=row+1;
                    }
                    else{
                        column=column+1;
                    }
                }
                else{
                    if(row==m-1){
                        column = column+1;
                    }
                    else{
                        row = row+1;
                    }
                }
                if(upd){
                    upd=0;
                }
                else{
                    upd=1;
                }
            }
            else{
                row = rowN;
                column=columnN;
            }
        }
        return ans;
    }
};
/* Python Solution ----- Simple and easy to understand
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m, n, r, c = len(mat), len(mat[0]), 0, 0
        diag = []
        
        def getNext(r, c):
            # go Northeast
            if (r+c)%2 == 0 and r > 0 and c < n-1:
                return r-1, c+1
            
            # go East
            elif ((r+c)%2 == 0 and r == 0 and c < n-1) or ((r+c)%2 == 1 and r == m-1 and c < n-1):
                return r, c+1
            
            # go Southwest
            elif (r+c)%2 == 1 and r < m-1 and c > 0:
                return r+1, c-1
            
            # go South
            return r+1, c
        
        while True:
            diag.append(mat[r][c])
            if (r, c) == (m-1, n-1):
                break
            r, c = getNext(r, c)
        return diag   
        */
